<!DOCTYPE html>
<html>
<head>
    <title>WebRTC Data Channel Example</title>
</head>
<body>
    <h1>WebRTC Data Channel Example</h1>
    <pre id="output"></pre>

    <script>
        const outputElement = document.getElementById('output');
        let ws, pc, dataChannel;

        function log(...args) {
            outputElement.textContent += args.join(' ') + '\n';
        }

        function setupWebSocket() {
            let proto = location.protocol === 'https:' ? 'wss' : 'ws';
            ws = new WebSocket(proto + '://' + location.host + '/ws');
            
            ws.onopen = () => {
                log('WebSocket connection opened');
                createConnection();
            };

            ws.onmessage = async event => {
                const message = JSON.parse(event.data);

                if (message.sdp) {
                    log('Received websocket SDP message');
                    await handleSDPMessage(message.sdp);
                } else if (message.candidate) {
                    log('Received websocket ICE candidate message');
                    try {
                        await pc.addIceCandidate(new RTCIceCandidate(message.candidate));
                    } catch (e) {
                        console.error('Error adding received ice candidate', e);
                    }
                } else {
                    log('Received unknown message type:', message);
                }
            };

            ws.onclose = () => {
                log('WebSocket connection closed, retrying in 5 seconds...');
                setTimeout(setupWebSocket, 5000);
            };

            ws.onerror = error => {
                log('WebSocket error: ' + error.message);
                ws.close();
            };
        }

        async function createConnection() {
            pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            pc.onicecandidate = event => {
                if (event.candidate) {
                    log('Sending ICE candidate ', JSON.stringify(event.candidate));
                    ws.send(JSON.stringify({ 'candidate': event.candidate }));
                }
            };

            pc.ondatachannel = event => {
                dataChannel = event.channel;
                setupDataChannel();
            };

            try {
                dataChannel = pc.createDataChannel('chat');
                setupDataChannel();

                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                log('Sending SDP offer:', offer);
                ws.send(JSON.stringify({ 'sdp': pc.localDescription }));
            } catch (e) {
                console.error('Failed to create offer:', e);
            }
        }

        async function handleSDPMessage(sdp) {
            if (sdp.type === 'offer') {
                if (pc.signalingState !== 'stable') {
                    // Create a new RTCPeerConnection
                    createConnection();
                }
                await pc.setRemoteDescription(new RTCSessionDescription(sdp));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                log('Sending SDP answer:', answer);
                ws.send(JSON.stringify({ 'sdp': pc.localDescription }));
            } else if (sdp.type === 'answer') {
                if (pc.signalingState === 'have-local-offer') {
                    await pc.setRemoteDescription(new RTCSessionDescription(sdp));
                } else {
                    log('Unexpected signaling state:', pc.signalingState);
                }
            }
        }

        function setupDataChannel() {
            dataChannel.onopen = () => {
                log('Data Channel Opened');
                setInterval(() => {
                    let hello = `Hello, my user agent is ${navigator.userAgent} and the current time is ${new Date().toLocaleTimeString()}`;
                    const message = JSON.stringify({ 'content': hello });
                    if (dataChannel.readyState === 'open') {
                        dataChannel.send(message);
                    }
                }, 5000);
            };

            dataChannel.onmessage = (event) => {
                const message = JSON.parse(event.data);
                log(`Received: ${message.content}`);
            };

            dataChannel.onclose = () => {
                log('Data Channel Closed');
            };

            dataChannel.onerror = (error) => {
                log('Data Channel Error: ' + error.message);
            };
        }

        setupWebSocket();
    </script>
</body>
</html>
