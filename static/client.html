<!DOCTYPE html>
<html>
<head>
    <title>Robust WebRTC Data Channel</title>
</head>
<body>
    <h1>Robust WebRTC Data Channel</h1>
    <pre id="output"></pre>

    <script>
        const outputElement = document.getElementById('output');
        let ws, peerConnections = {}, dataChannels = {}, iceCandidates = {}, sdpQueue = {};

        function log(...args) {
            console.log(...args);
            outputElement.textContent += args.join(' ') + '\n';
        }

        function setupWebSocket() {
            const proto = location.protocol === 'https:' ? 'wss' : 'ws';
            ws = new WebSocket(proto + '://' + location.host + '/ws');

            ws.onopen = () => {
                log('WebSocket connection opened to signaling server', ws.url);
            };

            ws.onmessage = async event => {
                const message = JSON.parse(event.data);
                log('WebSocket message received:', message);
                if (message.type === 'clients') {
                    await handleClientList(message.clients);
                } else if (message.sdp) {
                    await handleSDPMessage(message.id, message.sdp);
                } else if (message.candidate) {
                    await handleICECandidate(message.id, message.candidate);
                } else {
                    log('Received unknown message type:', message);
                }
            };

            ws.onclose = () => {
                log('WebSocket connection closed, retrying in 3 seconds...');
                setTimeout(setupWebSocket, 3000);
            };

            ws.onerror = error => {
                log('WebSocket error:', error.message);
                ws.close();
            };
        }

        async function handleClientList(clients) {
            const currentClientIds = Object.keys(peerConnections);
            for (const client of clients) {
                const id = client.ip; // Use IP as a unique identifier
                if (!currentClientIds.includes(id)) {
                    await createConnection(id);
                }
            }
        }

        async function createConnection(id) {
            const pc = createPeerConnection(id);
            peerConnections[id] = pc;

            if (!dataChannels[id]) {
                log('Creating Data Channel for', id);
                dataChannels[id] = pc.createDataChannel('chat');
                setupDataChannel(id);
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                ws.send(JSON.stringify({ id: id, 'sdp': pc.localDescription }));
                log('Sent SDP offer to WebSocket for', id);
            }
        }

        function createPeerConnection(id) {
            const pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            pc.onicecandidate = event => {
                if (event.candidate) {
                    log('ICE Candidate generated for', id, event.candidate);
                    ws.send(JSON.stringify({ id: id, 'candidate': event.candidate }));
                }
            };

            pc.ondatachannel = event => {
                log('Data Channel received from', id);
                dataChannels[id] = event.channel;
                setupDataChannel(id);
            };

            pc.oniceconnectionstatechange = () => {
                log('ICE connection state change for', id, pc.iceConnectionState);
                if (pc.iceConnectionState === 'disconnected' || pc.iceConnectionState === 'failed') {
                    log('ICE connection state is disconnected or failed for', id, 'closing peer connection');
                    pc.close();
                    delete peerConnections[id];
                    delete dataChannels[id];
                }

                // Apply any queued SDP messages once the connection becomes stable
                if (pc.iceConnectionState === 'completed' || pc.iceConnectionState === 'connected') {
                    applyQueuedSDP(id);
                }
            };

            pc.onsignalingstatechange = () => {
                log('Signaling state change for', id, pc.signalingState);
                if (pc.signalingState === 'stable') {
                    applyQueuedSDP(id);
                }
            };

            return pc;
        }

        async function handleSDPMessage(id, sdp) {
            try {
                log('Handling SDP message for', id, sdp);
                if (!peerConnections[id]) {
                    await createConnection(id);
                }
                const pc = peerConnections[id];
                if (sdp.type === 'offer') {
                    if (pc.signalingState !== 'stable') {
                        log('Peer connection is not stable, queuing the offer');
                        if (!sdpQueue[id]) sdpQueue[id] = [];
                        sdpQueue[id].push({ type: 'offer', sdp });
                        return;
                    }
                    await pc.setRemoteDescription(new RTCSessionDescription(sdp));
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    ws.send(JSON.stringify({ id: id, 'sdp': pc.localDescription }));
                    log('Sent SDP answer to WebSocket for', id);

                    // Add queued ICE candidates
                    while (iceCandidates[id] && iceCandidates[id].length) {
                        await pc.addIceCandidate(new RTCIceCandidate(iceCandidates[id].shift()));
                        log('Added queued ICE candidate for', id);
                    }
                } else if (sdp.type === 'answer') {
                    if (pc.signalingState !== 'have-local-offer') {
                        log('Peer connection does not have local offer, queuing the answer');
                        if (!sdpQueue[id]) sdpQueue[id] = [];
                        sdpQueue[id].push({ type: 'answer', sdp });
                        return;
                    }
                    await pc.setRemoteDescription(new RTCSessionDescription(sdp));
                    log('Set remote SDP answer for', id);
                }
            } catch (e) {
                log('Error handling SDP message:', e);
            }
        }

        async function handleICECandidate(id, candidate) {
            try {
                log('Handling ICE candidate for', id, candidate);
                const pc = peerConnections[id];
                if (pc && pc.remoteDescription && pc.remoteDescription.type) {
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                    log('Added ICE candidate for', id);
                } else {
                    if (!iceCandidates[id]) {
                        iceCandidates[id] = [];
                    }
                    iceCandidates[id].push(candidate);
                    log('Queued ICE candidate for', id);
                }
            } catch (e) {
                log('Error adding received ICE candidate:', e);
            }
        }

        function setupDataChannel(id) {
            const dataChannel = dataChannels[id];
            dataChannel.onopen = () => {
                log('Data Channel Opened with', id);
                setInterval(() => {
                    const message = JSON.stringify({ 
                        'userAgent': navigator.userAgent, 
                        'timestamp': new Date().toISOString() 
                    });
                    if (dataChannel.readyState === 'open') {
                        log('Sending message on Data Channel to', id, message);
                        dataChannel.send(message);
                    }
                }, 5000);
            };

            dataChannel.onmessage = event => {
                const message = JSON.parse(event.data);
                log(`Received from ${id}: UserAgent: ${message.userAgent}, Timestamp: ${message.timestamp}`);
            };

            dataChannel.onclose = () => {
                log('Data Channel Closed with', id);
            };

            dataChannel.onerror = error => {
                log('Data Channel Error with', id, error.message);
                dataChannel.close();
                setupWebSocket();
            };
        }

        async function applyQueuedSDP(id) {
            const pc = peerConnections[id];
            const queue = sdpQueue[id];
            if (pc.signalingState === 'stable' && queue && queue.length > 0) {
                log('Applying queued SDP messages for', id);
                while (queue.length > 0) {
                    const { type, sdp } = queue.shift();
                    if (type === 'offer') {
                        await handleSDPMessage(id, sdp);
                    } else if (type === 'answer') {
                        await handleSDPMessage(id, sdp);
                    }
                }
            }
        }

        setupWebSocket();
    </script>
</body>
</html>
